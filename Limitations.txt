Known limitations or discrepancies between platforms:

1. Linux events, semaphores, and mutexes don't support automatic reset
 - This has been fixed by use of a loadable kernel module (libCommon/module) which must be installed to use Mutexes, Semaphores, and Auto-Reset Events in Linux (otherwise their constructors will throw an exception)
 - Working on testing and submitting a kernel patch to add this functionality to the base kernel 

2. LinuxTimers do not support automatic reset
 - If the eventfd change goes over well, consider implementing the same thing for timerfd

3. WindowsTimers are cleared by setting the timer again to a very long timeout
 - No real impact, just kind of stupid

4. No method in Linux to wait for all file descriptors in a set before returning
 - No plan on implementing this at the moment, seems too easy to deadlock in Linux, and this can be left up to the user if they want something equivalent
 - This also means that waitAll should be disabled on Windows

5. Large pipe send operations may not complete without active traffic
 - It is unacceptable to block in the Pipe::send() call
 - If a user does a large write to a pipe that cannot be completed atomically, the system will write what it can and hold onto the rest
 - At the moment the unwritten portion is only pushed through at the next send (or an OutOfMemory exception is thrown if it still can't be completed)
 - This means that if there is never a 'next send', the data will remain unsent
 - On Windows this may be fixed by using overlapped I/O with a Named Pipe (rather that the current anonymous pipe)
 - On Linux this may be fixed by using asynchronous I/O with an eventfd

6. Mutex thread-id enforcement is different on windows vs linux
 - on windows, a mutex may be locked multiple times by the same thread, but must be released as many times before another thread can lock it
 - on linux, using eventfd, there is no kernel-level checking of thread-id
 - To fix:
   - Check thread-id in the mutex object (GetCurrentThreadId() in windows, pthread_self() in linux)
   - Prevent locking if the thread already owns the mutex
   - Prevent unlocking if the thread does not own the mutex (throw exception)
 - When locking a mutex through a wait function, lock() will not be called
   - Change the way HandleSets take parameters, take a new base class - HandleObject (or something) that provides getHandle() and wait callbacks
   - This way, the Mutex (and other objects) may do some handling before or after being waited on
